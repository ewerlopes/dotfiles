:DOC-CONFIG:
# Tangle by default to config.el, which is the most common case
#+property: header-args:emacs-lisp :tangle config.el
#+property: header-args :mkdirp yes :comments no
#+startup: fold
:END:

#+title: Doom Emacs configuration
#+author: Ewerton de Oliveira
#+email: ewerlopes@gmail.com

This is my Doom Emacs configuration. From this org file, all the necessary Doom Emacs config files are generated.

This file is written in literate programming. See the [[file:init.el][init.el]], [[file:packages.el][packages.el]] and [[file:config.el][config.el]] for the generated files.
This file is based on [[https://zzamboni.org/post/my-doom-emacs-configuration-with-commentary/][Diego Zamboni's configuration]].

* Doom config file overview
Doom Emacs uses three config files:

- =init.el= defines which of the existing Doom [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#modules][modules]] are loaded. A Doom module is a bundle of packages, configuration and commands, organized into a unit that can be toggled easily from this file.
- =packages.el= defines which [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#package-management][packages]] should be installed, beyond those that are installed and loaded as part of the enabled modules.
- =config.el= contains all [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#configuring-doom][custom configuration]] and code.

There are other files that can be loaded, but theses are the main ones. The load order of different files is [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#load-order][defined depending on the type of session]] being started.

All the config files are generated from this Org file, to try and make its meaning as clear as possible. All =package!= declarations are written to =packages.el=, all other LISP code is written to =config.el=.

** Config file headers

We start by simply defining the standard headers used by the three files. These headers come from the initial files generated by =doom install=, and contain either some Emacs-LISP relevant indicators like =lexical-binding=, or instructions about the contents of the file.

#+html: <details><summary>init.el</summary>
#+begin_src emacs-lisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://github.com/ewerlopes/dotfiles/blob/master/doom/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a link to Doom's Module Index where all
;;      of our modules are listed, including what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).
#+end_src
#+html: </details>

#+html: <details><summary>packages.el</summary>
#+begin_src emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://github.com/ewerlopes/dotfiles/blob/master/doom/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;; (package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/radian-software/straight.el#the-recipe-format
;; (package! another-package
;;   :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;; (package! this-package
;;   :recipe (:host github :repo "username/repo"
;;            :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;; (package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;; (package! builtin-package :recipe (:nonrecursive t))
;; (package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see radian-software/straight.el#279)
;; (package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;; (package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;; (unpin! pinned-package)
;; ...or multiple packages
;; (unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;; (unpin! t)
#+end_src
#+html: </details>

#+html: <details><summary>config.el</summary>
#+begin_src emacs-lisp :tangle config.el
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://github.com/ewerlopes/dotfiles/blob/master/doom/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets. It is optional.
;; (setq user-full-name "John Doe"
;;       user-mail-address "john@doe.com")

;; Doom exposes five (optional) variables for controlling fonts in Doom:
;;
;; - `doom-font' -- the primary font to use
;; - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
;; - `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;; - `doom-symbol-font' -- for symbols
;; - `doom-serif-font' -- for the `fixed-pitch-serif' face
;;
;; See 'C-h v doom-font' for documentation and more examples of what they
;; accept. For example:
;;
;;(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
;;      doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
;;
;; If you or Emacs can't find your font, use 'M-x describe-font' to look them
;; up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
;; refresh your font settings. If Emacs still can't find your font, it likely
;; wasn't installed correctly. Font issues are rarely Doom issues!

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'doom-one)

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/org/")


;; Whenever you reconfigure a package, make sure to wrap your config in an
;; `after!' block, otherwise Doom's defaults may override your settings. E.g.
;;
;;   (after! PACKAGE
;;     (setq x y))
;;
;; The exceptions to this rule:
;;
;;   - Setting file/directory variables (like `org-directory')
;;   - Setting variables which explicitly tell you to set them before their
;;     package is loaded (see 'C-h v VARIABLE' to look up their documentation).
;;   - Setting doom variables (which start with 'doom-' or '+').
;;
;; Here are some additional functions/macros that will help you configure Doom.
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;; Alternatively, use `C-h o' to look up a symbol (functions, variables, faces,
;; etc).
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src
#+html: </details>

* Doom modules

This code is written to the =init.el= to select which modules to load. Written here as-is for now, as it is quite well structured and clear.

#+begin_src emacs-lisp :tangle init.el
(doom! :input
       ;;bidi              ; (tfel ot) thgir etirw uoy gnipleh
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       ;;company           ; the ultimate code completion backend
       (corfu +orderless)  ; complete with cap(f), cape and a flying feather!
       ;;helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       ;;ivy               ; a search engine for love and life
       vertico             ; the search engine of the future

       :ui
       ;;deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       ;;doom-quit         ; DOOM quit-message prompts when you quit Emacs
       ;;(emoji +unicode)  ; 🙂
       hl-todo             ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       ;;indent-guides     ; highlighted indent columns
       ;;ligatures         ; ligatures and symbols to make your code pretty again
       ;;minimap           ; show a map of the code on the side
       modeline          ; snazzy, Atom-inspired modeline, plus API
       ;;nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       ;;smooth-scroll     ; So smooth you won't believe it's not butter
       ;;tabs              ; a tab bar for Emacs
       ;;treemacs          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       (vc-gutter +pretty) ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       ;;window-select     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       ;;(format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       ;;lispy             ; vim for lisp, for people who don't like vim
       ;;multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of
       ;;rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       ;;word-wrap         ; soft wrapping with language-aware indent

       :emacs
       dired             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       ;;eww               ; the internet is gross
       ;;ibuffer           ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

       :term
       ;;eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       ;;vterm             ; the best terminal emulation in Emacs

       :checkers
       syntax              ; tasing you for every semicolon you forget
       ;;(spell +flyspell) ; tasing you for misspelling mispelling
       ;;grammar           ; tasing grammar mistake every you make

       :tools
       ;;ansible
       ;;biblio            ; Writes a PhD for you (citation needed)
       ;;collab            ; buffers with friends
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       ;;direnv
       ;;docker
       ;;editorconfig      ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       lookup              ; navigate your code and its documentation
       ;;lsp               ; M-x vscode
       magit               ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       ;;pdf               ; pdf enhancements
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       ;;tree-sitter       ; syntax and parsing, sitting in a tree...
       ;;upload            ; map local to remote projects via ssh/ftp

       :os
       (:if (featurep :system 'macos) macos)  ; improve compatibility with macOS
       ;;tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       ;;beancount         ; mind the GAAP
       ;;(cc +lsp)         ; C > C++ == 1
       ;;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       ;;data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;dhall
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp          ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;factor
       ;;faust             ; dsp, but you get to keep your soul
       ;;fortran           ; in FORTRAN, GOD is REAL (unless declared INTEGER)
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;(graphql +lsp)    ; Give queries a REST
       ;;(haskell +lsp)    ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       ;;json              ; At least it ain't XML
       ;;(java +lsp)       ; the poster child for carpal tunnel syndrome
       ;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       ;;latex             ; writing papers in Emacs has never been so fun
       ;;lean              ; for folks with too much to prove
       ;;ledger            ; be audit you can be
       ;;lua               ; one-based indices? one-based indices
       markdown            ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       ;;nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       org                 ; organize your plain life in plain text
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;graphviz          ; diagrams for confusing yourself even more
       ;;purescript        ; javascript, but functional
       ;;python            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;(rust +lsp)       ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;(scheme +guile)   ; a fully conniving family of lisps
       sh                  ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;web               ; the tubes
       ;;yaml              ; JSON, but readable
       ;;zig               ; C, but simpler

       :email
       ;;(mu4e +org +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;emms
       ;;everywhere        ; *leave* Emacs!? You must be joking
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader

       :config
       ;;literate
       (default +bindings +smartparens))
#+end_src

* General configuration

My user information.

#+begin_src emacs-lisp
(setq user-full-name "Ewerton de Oliveira"
      user-mail-address "ewerlopes@gmail.com")
#+end_src

Change the Mac modifiers to my liking. I also disable passing Control characters to the system, to avoid that =C-M-space= launches the Character viewer instead of running =mark-sexp=.

#+begin_src emacs-lisp
(cond (IS-MAC
       (setq mac-command-modifier       'meta
             mac-option-modifier        'alt
             mac-right-option-modifier  'alt
             mac-pass-control-to-system nil)))
#+end_src

When at the beginning of the line, make =Ctrl-K= remove the whole line, instead of just emptying it.

#+begin_src emacs-lisp
(setq kill-whole-line t)
#+end_src

For some reason Doom disables auto-save and backup files by default. Let's reenable them.

#+begin_src emacs-lisp
(setq auto-save-default t
      make-backup-files t)
#+end_src

Disable exit confirmation.

#+begin_src emacs-lisp
(setq confirm-kill-emacs nil)
#+end_src

Doom configures =auth-sources= by default to include the Keychain on macOS, but it puts it at the beginning of the list. This causes creation of auth items to fail because the macOS Keychain sources do not support creation yet. I reverse it to leave =~/.authinfo.gpg= at the beginning.

#+begin_src emacs-lisp
(after! auth-source
  (setq auth-sources (nreverse auth-sources)))
#+end_src

** Visuals

*** Dashboard menu

I eliminate all but the first two items in the dashboard menu, since those are the only ones I still use sometimes.

#+begin_src emacs-lisp
(setq +doom-dashboard-menu-sections (cl-subseq +doom-dashboard-menu-sections 0 2))
#+end_src

*** Mixed pitch

=From the :ui zen module=

We'd like to use mixed pitch in certain modes. If we simply add a hook, when directly opening a file with (a new) Emacs =mixed-pitch-mode= runs before UI initialization, which is problematic. To resolve this, we create a hook that runs after UI initialization and both

- conditionally enables mixed-pitch-mode
- sets up the mixed pitch hooks

#+begin_src emacs-lisp :tangle no
(defvar mixed-pitch-modes '(org-mode LaTeX-mode markdown-mode gfm-mode Info-mode)
  "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
(defun init-mixed-pitch-h ()
  "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
  (when (memq major-mode mixed-pitch-modes)
    (mixed-pitch-mode 1))
  (dolist (hook mixed-pitch-modes)
    (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

#+begin_src emacs-lisp :tangle no
(autoload #'mixed-pitch-serif-mode "mixed-pitch"
  "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

(after! mixed-pitch :tangle no
  (defface variable-pitch-serif
    '((t (:family "serif")))
    "A variable-pitch face with serifs."
    :group 'basic-faces)
  (setq mixed-pitch-set-height t)
  (setq variable-pitch-serif-font (font-spec :family "Alegreya" :size 27))
  (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
  (defun mixed-pitch-serif-mode (&optional arg)
    "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
    (interactive)
    (let ((mixed-pitch-face 'variable-pitch-serif))
      (mixed-pitch-mode (or arg 'toggle)))))
#+end_src

#+begin_src emacs-lisp :tangle no
(set-char-table-range composition-function-table ?f '(["$?:ff?[fijlt]$" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?T '(["$?:Th$" 0 font-shape-gstring]))
#+end_src

Set base and variable-pitch fonts.

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "FiraCode Nerd Font" :size 18)
      doom-variable-pitch-font (font-spec :family "Alegreya" :size 28))
#+end_src

Allow mixed fonts in a buffer. This is particularly useful for Org mode, so I can mix source and prose blocks in the same document. I also manually enable =solaire-mode= in Org mode as a workaround for font scaling not working properly.

#+begin_src emacs-lisp
(add-hook! 'org-mode-hook #'mixed-pitch-mode)
;;(add-hook! 'org-mode-hook #'solaire-mode)
(setq mixed-pitch-variable-pitch-cursor nil)
#+end_src

*** Marginalia

#+begin_src emacs-lisp
(after! marginalia
  (setq marginalia-censor-variables nil)

  (defadvice! +marginalia--anotate-local-file-colorful (cand)
    "Just a more colourful version of `marginalia--anotate-local-file'."
    :override #'marginalia--annotate-local-file
    (when-let (attrs (file-attributes (substitute-in-file-name
                                       (marginalia--full-candidate cand))
                                      'integer))
      (marginalia--fields
       ((marginalia--file-owner attrs)
        :width 12 :face 'marginalia-file-owner)
       ((marginalia--file-modes attrs))
       ((+marginalia-file-size-colorful (file-attribute-size attrs))
        :width 7)
       ((+marginalia--time-colorful (file-attribute-modification-time attrs))
        :width 12))))

  (defun +marginalia--time-colorful (time)
    (let* ((seconds (float-time (time-subtract (current-time) time)))
           (color (doom-blend
                   (face-attribute 'marginalia-date :foreground nil t)
                   (face-attribute 'marginalia-documentation :foreground nil t)
                   (/ 1.0 (log (+ 3 (/ (+ 1 seconds) 345600.0)))))))
      ;; 1 - log(3 + 1/(days + 1)) % grey
      (propertize (marginalia--time time) 'face (list :foreground color))))

  (defun +marginalia-file-size-colorful (size)
    (let* ((size-index (/ (log10 (+ 1 size)) 7.0))
           (color (if (< size-index 10000000) ; 10m
                      (doom-blend 'orange 'green size-index)
                    (doom-blend 'red 'orange (- size-index 1)))))
      (propertize (file-size-human-readable size) 'face (list :foreground color)))))
#+end_src

*** Writeroom :tangle no

#+begin_src emacs-lisp
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")
(defvar +zen-org-starhide t
  "The value `org-modern-hide-stars' is set to.")

(after! writeroom-mode
  (defvar-local +zen--original-org-indent-mode-p nil)
  (defvar-local +zen--original-mixed-pitch-mode-p nil)
  (defun +zen-enable-mixed-pitch-mode-h ()
    "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
    (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
      (if writeroom-mode
          (progn
            (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
            (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
        (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1)))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-adapt-indentation
            'org-modern-mode
            'org-modern-star
            'org-modern-hide-stars)
  (add-hook 'writeroom-mode-enable-hook
            (defun +zen-prose-org-h ()
              "Reformat the current Org buffer appearance for prose."
              (when (eq major-mode 'org-mode)
                (setq display-line-numbers nil
                      visual-fill-column-width 60
                      org-adapt-indentation nil)
                (when (modulep 'org-modern)
                  (setq-local org-modern-star '("🙘" "🙙" "🙚" "🙛")
                              ;; org-modern-star '("🙐" "🙑" "🙒" "🙓" "🙔" "🙕" "🙖" "🙗")
                              org-modern-hide-stars +zen-org-starhide)
                  (org-modern-mode -1)
                  (org-modern-mode 1))
                (setq
                 +zen--original-org-indent-mode-p org-indent-mode
                 (org-indent-mode -1))))
            (add-hook 'writeroom-mode-disable-hook
                      (defun +zen-nonprose-org-h ()
                        "Reverse the effect of `+zen-prose-org'."
                        (when (eq major-mode 'org-mode)
                          (when (bound-and-true-p org-modern-mode)
                            (org-modern-mode -1)
                            (org-modern-mode 1))
                          (when +zen--original-org-indent-mode-p (org-indent-mode 1)))))))
#+end_src

*** Window
Maximize the window upon startup.

#+begin_src emacs-lisp
(setq initial-frame-alist '((top . 1) (left . 1) (width . 114) (height . 32)))
;;(add-to-list 'initial-frame-alist '(maximized))
#+end_src

*** Modeline

Enable showing a word count in the modeline. This is only shown for the modes listed in =doom-modeline-continuous-word-count-modes= (Markdown, GFM and Org by default).

#+begin_src emacs-lisp
(setq doom-modeline-enable-word-count t)
#+end_src

*** Scrolling

Enable pixel scrolling

#+begin_src emacs-lisp
;;(pixel-scroll-precision-mode 1)
#+end_src

** Org

I use standard /doom emacs/ =org-todo-keywords=. See them [[https://github.com/doomemacs/doomemacs/blob/master/modules/lang/org/config.el#L151][here]].

*** Heading sizes

#+begin_src emacs-lisp
;; Resize Org headings
(after! org
(dolist (face '((org-level-1 . 1.35)
                (org-level-2 . 1.3)
                (org-level-3 . 1.2)
                (org-level-4 . 1.1)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :font "Roboto" :weight 'bold :height (cdr face)))

;; Make the document title a bit bigger
(set-face-attribute 'org-document-title nil :font "Roboto" :weight
'bold :height 2.0))
#+end_src

*** Heading format

#+begin_src emacs-lisp :tangle packages.el
(package! org-modern)
#+end_src

#+begin_src emacs-lisp
(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :config
  (setq
      org-modern-star ["◉" "○" "✸" "✿" "✤" "✜" "◆" "▶"]
      org-modern-table-vertical 1
      org-modern-table-horizontal 0.2
      org-modern-list '((43 . "➤")
                        (45 . "–")
                        (42 . "•"))
      org-auto-align-tags t
      org-tags-column 0
      org-catch-invisible-edits 'show-and-error
      org-special-ctrl-a/e t
      org-insert-heading-respect-content t

      ;; Org styling, hide markup etc.
      org-hide-emphasis-markers t
      org-pretty-entities t
      org-agenda-tags-column 0
      org-ellipsis "…")

  (global-org-modern-mode))
#+end_src

*** Behavior

**** Defaults

#+begin_src emacs-lisp
(setq org-directory "~/org"                      ; let's put files here
      org-log-into-drawer t                       ; changes of state into a LOGBOOK
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-use-babel nil                    ; I don't want things to run automatically as I export
      org-export-with-sub-superscripts '{}        ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
      org-export-headline-levels 6
      org-export-with-todo-keywords t
      org-export-with-planning t
      org-export-with-priority t
      org-export-with-creator t
      org-export-with-properties nil
      org-export-with-tags t)
#+end_src

I also like the :comments header-argument, so let's make that a default.

#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

*** Clock

#+begin_src emacs-lisp
;; Resume clocking task when emacs restarts.
(org-clock-persistence-insinuate)
;; Show lot of clocking history so it's easy to pick items off the C-F11 list
(setq org-clock-history-length 23)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)
#+end_src

*** Habits

I use this for repeating tasks (such as exercise) in my org-agenda view. This allows for collecting certain datapoints in variables / notes.

#+begin_src emacs-lisp
(require 'org-habit)
#+end_src

#+begin_src emacs-lisp
(defun get-habits-from-file ()
  (org-map-entries
   (lambda ()
     (when (string= (org-entry-get nil "STYLE") "habit")
       (cons (org-get-heading t t t t)
             (org-entry-get nil "LAST_REPEAT"))))
   "STYLE=\"habit\"" 'file))

(defun count-habit-completions (last-repeat)
  (let* ((now (current-time))
         (week-start (time-subtract now (days-to-time (nth 6 (decode-time now)))))
         (last-done (org-time-string-to-time last-repeat)))
    (if (time-less-p week-start last-done)
        1
      0)))

(defun parse-habit-data (habit-name last-repeat)
  (let ((data '())
        (max-streak 0)
        (current-streak 0))
    (org-map-entries
     (lambda ()
       (let ((state-changes (org-entry-get nil "LOGGING" t)))
         (when state-changes
           (dolist (change (split-string state-changes "\n"))
             (when (string-match "\\[$[0-9]+-[0-9]+-[0-9]+$.*$$ State \"DONE\"" change)
               (push (match-string 1 change) data))))))
     (concat "+STYLE=\"habit\"+" (regexp-quote habit-name))
     'file)
    (setq data (nreverse data))
    (let* ((now (current-time))
           (streak-end now)
           (day-sec 86400))
      (when last-repeat
        (push last-repeat data))
      (dolist (date data)
        (let ((date-time (org-time-string-to-time date)))
          (if (time-less-p
               (time-subtract streak-end (seconds-to-time day-sec))
               date-time)
              (setq current-streak (1+ current-streak))
            (setq max-streak (max max-streak current-streak))
            (setq current-streak 1))
          (setq streak-end date-time)))
      (setq max-streak (max max-streak current-streak)))
    (list current-streak max-streak)))

(defun calculate-trend (habit-name)
  (let* ((last-repeat (cdr (assoc habit-name (get-habits-from-file))))
         (this-week (count-habit-completions last-repeat))
         (last-week-time (time-subtract (current-time) (days-to-time 7)))
         (last-week (if (time-less-p (org-time-string-to-time last-repeat) last-week-time) 0 1)))
    (cond ((> this-week last-week) "↑")
          ((< this-week last-week) "↓")
          (t "→"))))

(defun insert-ultra-fancy-habit-summary ()
  (interactive)
  (let ((habits (get-habits-from-file)))
    (insert "| Habit | This Week | Streak | Max Streak | Trend |\n|---|---|---|---|---|\n")
    (dolist (habit habits)
      (let* ((name (car habit))
             (last-repeat (cdr habit))
             (this-week (count-habit-completions last-repeat))
             (streak-data (parse-habit-data name last-repeat))
             (streak (car streak-data))
             (max-streak (cadr streak-data))
             (trend (calculate-trend name)))
        (insert (format "| %s | %d/7 | %d | %d | %s |\n"
                        name this-week streak max-streak trend))))
    (org-table-align)))

(global-set-key (kbd "C-c m") 'insert-ultra-fancy-habit-summary)
#+end_src

I like keeping repeaters around:

#+begin_src emacs-lisp
(setq org-habit-show-all-today t
      org-habit-show-habits-only-for-today nil)
#+end_src

**** Capture

  Let's setup some org-capture templates, and make them visually nice to access. =doct= (Declarative Org Capture Templates) seems to be a nicer way to set up org-capture.

  #+begin_src emacs-lisp :tangle packages.el
  (package! doct
     :recipe (:host github :repo "progfolio/doct")
     :pin "506c22f365b75f5423810c4933856802554df464")
  #+end_src

  #+begin_src emacs-lisp
  (use-package! doct
      :commands doct)
  #+end_src

  #+begin_src emacs-lisp
      (after! org-capture
      ;;<<prettify-capture>>
      (defun +doct-icon-declaration-to-icon (declaration)
      "Convert :icon declaration to icon"
      (let ((name (pop declaration))
            (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
            (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
            (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
            (apply set `(,name :face ,face :v-adjust ,v-adjust))))

      (defun +doct-iconify-capture-templates (groups)
      "Add declaration's :icon to each template group in GROUPS."
      (let ((templates (doct-flatten-lists-in groups)))
            (setq doct-templates (mapcar (lambda (template)
                                          (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                      (spec (plist-get (plist-get props :doct) :icon)))
                                          (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                        "\t"
                                                                        (nth 1 template))))
                                          template)
                                    templates))))

      (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

      (setq +org-capture-todo-file (file-truename (concat (getenv "HOME") "/org/gtd/inbox.org")))
      (defvar +org-capture-slipbox (file-truename (concat (getenv "HOME") "/org/library/inbox.org")))

      (defun jethro/org-capture-slipbox ()
      (interactive)
      (org-capture nil "s"))

      (defun set-org-capture-templates ()
      (setq org-capture-templates
      (doct `(("Inbox" :keys "t"
                  :file +org-capture-todo-file
                  :prepend t
                  :headline "Inbox"
                  :type entry
                  :template ("* TODO %?"
                              "%i %a"))
                  ("Slip-box" :keys "s"
                  :file +org-capture-slipbox
                  :prepend t
                  :headline "Inbox"
                  :type entry
                  :template ("* %?"))
                  ("Link" :keys "L"
                  :file +org-capture-slipbox
                  :prepend t
                  :headline "Inbox"
                  :type entry
                  :immediate-finish t
                  :template ("* IDEA [#C] %:description\n:PROPERTIES:\n:CREATED: %U\n:END:\n%:link\n%:initial\n"))
                  ("Interesting" :keys "i"
                  :file +org-capture-todo-file
                  :prepend t
                  :headline "Interesting"
                  :type entry
                  :template ("* [ ] %{desc}%? :%{i-type}:"
                              "%i %a")
                  :children (("Webpage" :keys "w"
                              :desc "%(org-cliplink-capture) "
                              :i-type "read:web")
                              ("Article" :keys "a"
                              :desc ""
                              :i-type "read:reaserch")
                              ))
                  ("Tasks" :keys "k"
                  :file +org-capture-todo-file
                  :prepend t
                  :headline "Tasks"
                  :type entry
                  :template ("* TODO %? %^G%{extra}"
                              "%i %a")
                  :children (("General Task" :keys "k"
                              :extra "")
                              ("Task with deadline" :keys "d"
                              :extra "\nDEADLINE: %^{Deadline:}t")
                              ("Scheduled Task" :keys "s"
                              :extra "\nSCHEDULED: %^{Start time:}t")))
                  ("Project" :keys "p"
                  :prepend t
                  :type entry
                  :headline "Inbox"
                  :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                  :file ""
                  :custom (:time-or-todo "")
                  :children (("Project-local todo" :keys "t"
                              :time-or-todo "TODO"
                              :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                              :time-or-todo "%U"
                              :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                              :time-or-todo "%U"
                              :heading "Unreleased"
                              :file +org-capture-project-changelog-file)))
                  ("Centralised project templates"
                  :keys "o"
                  :type entry
                  :prepend t
                  :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                  :children (("Project todo"
                              :keys "t"
                              :prepend nil
                              :time-or-todo "TODO"
                              :heading "Tasks"
                              :file +org-capture-central-project-todo-file)
                              ("Project note"
                              :keys "n"
                              :time-or-todo "%U"
                              :heading "Notes"
                              :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                              :keys "c"
                              :time-or-todo "%U"
                              :heading "Unreleased"
                              :file +org-capture-central-project-changelog-file)))))))

(set-org-capture-templates)
(unless (display-graphic-p)
(add-hook 'server-after-make-frame-hook
            (defun org-capture-reinitialise-hook ()
            (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                              #'org-capture-reinitialise-hook))))))
  #+end_src

Some functions from Jethro Kuan used to process the captured inbox

#+begin_src emacs-lisp
(defun jethro/org-process-inbox ()
  "Called in org-agenda-mode, processes all inbox items."
  (interactive)
  (org-agenda-bulk-mark-regexp "inbox:")
  (jethro/bulk-process-entries))

(defvar jethro/org-current-effort "1:00"
  "Current effort for agenda items.")

(defun jethro/my-org-agenda-set-effort (effort)
  "Set the effort property for the current headline."
  (interactive
   (list (read-string (format "Effort [%s]: " jethro/org-current-effort) nil nil jethro/org-current-effort)))
  (setq jethro/org-current-effort effort)
  (org-agenda-check-no-diary)
  (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                       (org-agenda-error)))
         (buffer (marker-buffer hdmarker))
         (pos (marker-position hdmarker))
         (inhibit-read-only t)
         newhead)
    (org-with-remote-undo buffer
      (with-current-buffer buffer
        (widen)
        (goto-char pos)
        (org-show-context 'agenda)
        (funcall-interactively 'org-set-effort nil jethro/org-current-effort)
        (end-of-line 1)
        (setq newhead (org-get-heading)))
      (org-agenda-change-all-lines newhead hdmarker))))

(defun jethro/org-agenda-process-inbox-item ()
  "Process a single item in the org-agenda."
  (org-with-wide-buffer
   (org-agenda-set-tags)
   (org-agenda-priority)
   (call-interactively 'jethro/my-org-agenda-set-effort)
   (org-agenda-refile nil nil t)))

(defun jethro/bulk-process-entries ()
  (let ())
  (if (not (null org-agenda-bulk-marked-entries))
      (let ((entries (reverse org-agenda-bulk-marked-entries))
            (processed 0)
            (skipped 0))
        (dolist (e entries)
          (let ((pos (text-property-any (point-min) (point-max) 'org-hd-marker e)))
            (if (not pos)
                (progn (message "Skipping removed entry at %s" e)
                       (cl-incf skipped))
              (goto-char pos)
              (let (org-loop-over-headlines-in-active-region) (funcall 'jethro/org-agenda-process-inbox-item))
              ;; `post-command-hook' is not run yet.  We make sure any
              ;; pending log note is processed.
              (when (or (memq 'org-add-log-note (default-value 'post-command-hook))
                        (memq 'org-add-log-note post-command-hook))
                (org-add-log-note))
              (cl-incf processed))))
        (org-agenda-redo)
        (unless org-agenda-persistent-marks (org-agenda-bulk-unmark-all))
        (message "Acted on %d entries%s%s"
                 processed
                 (if (= skipped 0)
                     ""
                   (format ", skipped %d (disappeared before their turn)"

                           skipped))
                 (if (not org-agenda-persistent-marks) "" " (kept marked)")))))

(defun jethro/org-inbox-capture ()
  (interactive)
  "Capture a task in agenda mode."
  (org-capture nil "t"))

(after! org-agenda (map! :map org-agenda-mode-map
      "C-c c i" #'org-agenda-clock-in
      "C-c c I" #'jethro/clock-in-and-advance
      "C-c c r" #'jethro/org-process-inbox
      "C-c c R" #'org-agenda-refile
      "C-c c C" #'jethro/org-inbox-capture))

(defun jethro/advance-todo ()
  (org-todo 'right)
  (remove-hook 'org-clock-in-hook #'jethro/advance-todo))

(defun jethro/clock-in-and-advance ()
  (interactive)
  (add-hook 'org-clock-in-hook 'jethro/advance-todo)
  (org-agenda-clock-in))

(defun jethro/tag-new-node-as-draft ()
  (org-roam-tag-add '("draft")))
(add-hook 'org-roam-capture-new-node-hook #'jethro/tag-new-node-as-draft)
#+end_src

*** Agenda

Adding the proper files to pull agenda from. This adds in the project-based files in addition, since each could/can have their own todo.org file.

#+begin_src emacs-lisp
(setq org-agenda-files (apply 'append
      (mapcar
       (lambda (directory)
         (directory-files-recursively
           directory org-agenda-file-regexp))
           '("~/org/gtd"))))
#+end_src

The agenda is nice, but a souped up version is nicer.

#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda)
#+end_src

#+begin_src emacs-lisp
(eval-after-load 'org
  '(progn
     (setq org-agenda-start-day "-0d")
     (setq org-agenda-start-on-weekday nil)))

(use-package! org-super-agenda
  :after org-agenda
  :init
  (setq
        org-agenda-time-grid
        (quote
         ((daily today require-timed)
          (0700 0800 0900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100 2200 2300)
          "......" "-----------------------------------------------------"))
        org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done t
        org-agenda-include-deadlines t
        org-agenda-include-diary t
        org-agenda-block-separator nil
        org-agenda-compact-blocks t
        org-agenda-span 1
        org-agenda-start-with-log-mode t
        org-agenda-custom-commands
        '(("o" "Overview"
                    ((agenda "" ((org-agenda-span 'day)
                                 (org-super-agenda-groups
                                  '((:name "\nToday"
                                           :time-grid t
                                           :date today
                                           :todo "TODAY"
                                           :scheduled today
                                           :order 1)))))
                     (alltodo "" ((org-agenda-overriding-header "\nCategories")
                                  (org-super-agenda-groups
                                   '(
                                     (:name "Started"
                                      :todo "STRT"
                                      :order 5)
                                     (:name "Important"
                                      :tag "Important"
                                      :priority "A"
                                      :order 3)
                                     (:name "Due Today"
                                      :deadline today
                                      :order 4)
                                     (:name "Due Soon"
                                      :deadline future
                                      :order 8)
                                     (:name "Overdue"
                                      :deadline past
                                      :scheduled past
                                      :face error
                                      :order 7)
                                      (:name "To Refile"
                                      :and(
                                          :todo "TODO"
                                          :not (:habit t)
                                      )
                                      :order 9)
                                     (:name "To read"
                                      :tag "Read"
                                      :order 30)
                                     (:name "Waiting"
                                      :todo "WAITING"
                                      :order 20)
                                     (:name "Trivial"
                                            :priority<= "C"
                                            :tag ("Trivial" "Unimportant")
                                            :todo ("SOMEDAY")
                                            :order 90)
                                     (:discard (:anything t))))))))))
  :config
  (org-super-agenda-mode))
  #+end_src

*** protocol

#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src

*** Org-roam

**** Basic Settings

#+begin_src emacs-lisp :tangle packages.el
(package! org-roam)
#+end_src

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :init
  (setq org-roam-directory (file-truename (concat (getenv "HOME") "/org/library/"))
        ;;org-roam-db-location "~/.org/library/org-roam.db"
        )
   :custom
   (org-roam-database-connector 'sqlite-builtin)
   (org-roam-setup)
  :bind (("C-c n f" . org-roam-node-find)
          ("C-c n r" . org-roam-node-random)
          (:map org-mode-map
                (("C-c n i" . org-roam-node-insert)
                ("C-c n o" . org-id-get-create)
                ("C-c n t" . org-roam-tag-add)
                ("C-c n a" . org-roam-alias-add)
                ("C-c n l" . org-roam-buffer-toggle)))))
#+end_src

**** Roam Capture settings

These are settings related to the way I do work, initially inspired by [[https://jethrokuan.github.io/org-roam-guide/][Jethro Kuan's]]

#+begin_src emacs-lisp
(setq time-stamp-active t
      time-stamp-start "#\\+last_modified:[ \t]*"
      time-stamp-end "$"
      time-stamp-format "\[%Y-%02m-%02d %3a %02H:%02M\]")
(add-hook 'before-save-hook 'time-stamp nil)

(setq org-roam-capture-templates
      '(("m" "main" plain
         "%?"
         :if-new
         (file+head "main/${slug}.org"
          "#+title: ${title}
          #+hugo_tags: noexport
          #+date: %U\n\n")
         :immediate-finish t
         :unnarrowed t)
        ("p" "person" plain
         "%?"
         :if-new
         (file+head "main/${slug}.org"
          "#+title: ${title}
           #+filetags: :person:
          #+date: %U\n\n")
         :immediate-finish t
         :unnarrowed t)
        ("w" "work" plain
         "%?"
         :if-new
         (file+head "work/${slug}.org"
          "#+title: ${title}
           #+filetags: :private:
          #+date: %U\n\n")
         :immediate-finish t
         :unnarrowed t)
        ("r" "reference" plain
         "%?"
         :if-new
         (file+head "reference/${title}.org"
          "#+title: ${title}
          #+date: %U\n\n")
         :immediate-finish t
         :unnarrowed t)
        ("a" "article" plain
         "%?"
         :if-new
         (file+head "articles/${title}.org"
                   "#+HUGO_BASE_DIR: ~
                   #+HUGO_SECTION: ./posts
                   #+TITLE: ${title}
                   #+DATE: %U
                   #+HUGO_TAGS: draft
                   #+macro: sidenote @@html:{{%/* sidenote \"$1\" $2 */%}} $3 {{%/* /sidenote */%}}@@
                   #+HUGO_DRAFT: true\n")
         :immediate-finish t
         :unnarrowed t)))
#+end_src

It'd also be useful to differentiate the different types of zettels at completion time by their location (slip-box folder).

#+begin_src emacs-lisp
(after! org-roam
(cl-defmethod org-roam-node-type ((node org-roam-node))
  "Return the TYPE of NODE."
  (condition-case nil
      (file-name-nondirectory
       (directory-file-name
        (file-name-directory
         (file-relative-name
          (org-roam-node-file node)
          org-roam-directory))))
    (error ""))))
#+end_src

#+begin_src emacs-lisp
(setq org-roam-node-display-template
      (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
#+end_src